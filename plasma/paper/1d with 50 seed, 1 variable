#-----------------------------------------------------------# í•„ìš”í•œ í•¨ìˆ˜ ##
# ë²¡í„°ì˜ L2 norm ê³„ì‚° í•¨ìˆ˜
compute_norm <- function(vector) {
  return(sqrt(sum(vector^2)))
}

# í™•ë¥  ê³„ì‚° í•¨ìˆ˜ (Prop 3.1 ë‚´ë¶€)
compute_probability <- function(nu, t, P, k, norm_lx_h) {
  tryCatch({
    q_val <- qchisq(P, df = 1, ncp = t^2) #qchisq value ì„¤ì •
    lhs <- q_val / ((t * sqrt(5 / nu)) + 1) #ì´ ê°’ì´ k^2ë³´ë‹¤ í¬ë©´, probabilityê°€ 0ìœ¼ë¡œ ê°.
    
    if (lhs <= k^2) {
      threshold <- (nu * q_val) / (k^2)
      probability <- pchisq(threshold, df = nu, lower.tail = FALSE) #probability term
      
      if (is.na(probability) || is.nan(probability)) return(1e-6)
      return(probability)
    } else {
      return(0) #ì´ ê°’ì´ k^2ë³´ë‹¤ í¬ë©´, probabilityê°€ 0ìœ¼ë¡œ ê°.
    }
  }, error = function(e) {
    warning("compute_probability ê³„ì‚° ì˜¤ë¥˜ ë°œìƒ")
    return(0)
  })
}


# ì ë¶„ í•¨ìˆ˜
integrand <- function(t, k, nu, P, norm_lx_h) {
  exp_term <- exp(-t^2 / (2 * norm_lx_h^2))
  if (exp_term < 1e-5) return(0) #exp term ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ê·¸ëƒ¥ 0 ë°˜í™˜
  
  prob_term <- compute_probability(nu, t, P, k, norm_lx_h)
  return(exp_term * prob_term)
}

find_upper_bound_t <- function(k, nu, P) {
  t_seq <- seq(0.01, 100, by = 0.05)  # íƒìƒ‰ êµ¬ê°„
  valid_t <- sapply(t_seq, function(t) {
    q_val <- qchisq(P, df = 1, ncp = t^2)
    lhs <- q_val / ((t * sqrt(5 / nu)) + 1)
    return(lhs <= k^2)
  })
  
  if (any(valid_t)) {
    return(max(t_seq[valid_t]))
  } else {
    warning("ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” tê°€ ì—†ìŒ â€” fallback to t = 10")
    return(10)
  }
}

# k-factor ê³„ì‚° í•¨ìˆ˜
find_k_factor <- function(nu, norm_lx_h, P = 0.90, gamma = 0.95, index = NA) {
  start_time <- Sys.time()
  cat("â–¶ï¸ k-factor ê³„ì‚° ì‹œì‘: index =", index, "\n")
  
  obj_func <- function(k) {
    upper_bound <- find_upper_bound_t(k, nu, P)
    
    if (is.na(upper_bound) || is.infinite(upper_bound) || upper_bound < 1e-6) {
      warning("upper_boundê°€ ì´ìƒí•¨ â†’ fallback")
      return(Inf) #upperbound ìƒí•œê°’ì„ infë¡œ ì„¤ì •
    }
    
    result <- tryCatch({
      integral_result <- integrate(integrand, lower = 0, upper = upper_bound,
                                   k = k, nu = nu, P = P, norm_lx_h = norm_lx_h)$value
      if (is.na(integral_result) || is.nan(integral_result)) return(Inf)
      pi_term <- sqrt(2 / (pi * norm_lx_h^2))
      error <- abs((pi_term * integral_result) - gamma)
      
      cat("  â³ k =", round(k, 5), 
          ", upper bound of t ", upper_bound, 
          ", integral =", round(pi_term * integral_result, 5), 
          ", error =", round(error, 5), "\n")
      
    }, error = function(e) {
      warning("ì ë¶„ ì‹¤íŒ¨")
      return(Inf)
    })
    
    return(result)
  }
  
  
  tryCatch({
    return(optimize(obj_func, interval = c(0.01, 5), tol = 1e-2)$minimum)
    elapsed <- Sys.time() - start_time
    cat("âœ… index =", index, ", ìµœì  k =", round(out, 5), ", ì‹œê°„:", round(elapsed, 2), "ì´ˆ\n")
    
  }, error = function(e) {
    warning("k ìµœì í™” ì‹¤íŒ¨")
    return(sqrt(nu*qchisq(p=0.90, df=1, ncp=norm_lx_h^2)/qchisq(p=1-gamma, df=nu, ncp=0))) # ìµœì í™” ì‹¤íŒ¨ ì‹œ ê·¼ì‚¬ê°’ ì‚¬ìš©
  })
}

#-----------------------------------------------------------# í•„ìš”í•œ í•¨ìˆ˜ ##




library(splines)
library(gam)
library(MASS)
library(parallel)

# ì‹œë“œ ë°˜ë³µ
seeds <- 1:50
picp_list <- numeric(length(seeds))
nmpiw_list <- numeric(length(seeds))
getwd()
for (s in seeds) {
  cat("â–¶ï¸ Seed", s, "ê³„ì‚° ì‹œì‘...\n")
  start_time <- Sys.time()
  
  # ----- ë°ì´í„° ì¤€ë¹„ ë° ì •ì œ -----
  data <- read.csv("~/Downloads/plasma.csv")
  x <- data$AGE
  y <- data$CALORIES
  
  clean_data <- function(x, y) {
    idx <- which(!is.na(x) & !is.na(y) & !is.infinite(x) & !is.infinite(y))
    return(list(x = x[idx], y = y[idx]))
  }
  
  set.seed(s)
  m <- length(y)
  n_test <- 115
  n_train <- m - n_test
  idx <- sample(seq_len(m))
  train_idx <- idx[1:n_train]
  test_idx <- idx[(n_train+1):m]
  
  train_x <- x[train_idx]
  raw_train_y <- y[train_idx]
  test_x <- x[test_idx]
  raw_test_y <- y[test_idx]
  
  train_clean <- clean_data(train_x, raw_train_y)
  cat("Seed", s, ": transform í›„ usable obs =", length(train_x), "\n")
  train_x <- train_clean$x
  raw_train_y <- train_clean$y
  
  # í‰ê·  ë° ë¶„ì‚° ì¶”ì •
  raw_fit <- smooth.spline(train_x, raw_train_y, cv = FALSE)
  raw_pred_y <- predict(raw_fit, train_x)$y
  raw_residuals <- raw_train_y - raw_pred_y
  fit_var <- gam(raw_residuals^2 ~ s(train_x), family = Gamma(link = "log"))
  var_list <- predict(fit_var, newdata = data.frame(train_x = train_x), type = "response")
  var_list <- pmax(var_list, 1e-4)
  transform_y <- raw_train_y / sqrt(var_list)
  
  transform_clean <- clean_data(train_x, transform_y)
  train_x <- transform_clean$x
  train_y <- transform_clean$y
  
  # ë‹¨ì¼ ë¶„ì‚° ì¶”ì •
  fit <- smooth.spline(train_x, train_y, cv = FALSE)
  residuals <- predict(fit, train_x)$y - train_y
  B <- bs(train_x, df = max(fit$df), 3)
  D <- diff(diag(ncol(B)), differences = 2)
  S_inv <- ginv(t(B) %*% B + fit$lambda * t(D) %*% D)
  smoother_matrix <- B %*% S_inv %*% t(B)
  I_n <- diag(length(train_x))
  residual_matrix <- I_n - smoother_matrix
  
  estimated_variance <- (t(residuals) %*% residuals) / (sum(diag(t(residual_matrix) %*% residual_matrix)))
  
  # nu ê³„ì‚° 
  numerator <- sum(diag(t(residual_matrix) %*% residual_matrix))^2
  denominator <- sum(diag((t(residual_matrix) %*% residual_matrix)^2))
  nu <- numerator / denominator
  
  ### k factor ê³„ì‚° ###
  # 1. smoothing vectorì˜ norm ê³„ì‚°
  norm_lx_h_values <- apply(smoother_matrix, 2, compute_norm)
  rounded_nlh <- round(norm_lx_h_values, 5)  # float ì˜¤ì°¨ ë°©ì§€ìš©
  
  # 2. ì²« ë²ˆì§¸ ì‹œë“œì— ëŒ€í•´ì„œë§Œ k-factor ê³„ì‚°
  if (s == 1) {
    unique_nlh <- sort(unique(rounded_nlh))
    k_lookup <- mclapply(unique_nlh, function(nlh) {
      find_k_factor(nu = nu, norm_lx_h = nlh)
    }, mc.cores = detectCores() - 1)
    names(k_lookup) <- unique_nlh
    saveRDS(k_lookup, "k_lookup_saved.rds")
  } else {
    k_lookup <- readRDS("k_lookup_saved.rds")
    missing_nlh <- setdiff(unique(rounded_nlh), names(k_lookup))
    if (length(missing_nlh) > 0) {
      cat("âš ï¸ ëˆ„ë½ëœ k-factor ê³„ì‚°:", length(missing_nlh), "ê°œ\n") #ì• ì‹œë“œì—ì„œ ê³„ì‚°ë˜ì§€ ì•Šì€xê°’ë“¤ì— ëŒ€í•œ k factorëŠ” ì¶”ê°€ì ìœ¼ë¡œ ê³„ì‚°í•´ì„œ k_lookupì— ëˆ„ì  ì €ì¥
      new_k <- mclapply(missing_nlh, function(nlh) {
        find_k_factor(nu = nu, norm_lx_h = as.numeric(nlh))
      }, mc.cores = detectCores() - 1)
      names(new_k) <- missing_nlh
      k_lookup <- c(k_lookup, new_k)
      saveRDS(k_lookup, "k_lookup_saved.rds")
    }
  }
  
  k_factors <- as.numeric(unlist(k_lookup[as.character(rounded_nlh)]))
  pred_y <- predict(fit, train_x)$y
  TI_upper <- pred_y + k_factors * as.numeric(estimated_variance)
  TI_lower <- pred_y - k_factors * as.numeric(estimated_variance)
  raw_TI_upper <- TI_upper * sqrt(var_list)
  raw_TI_lower <- TI_lower * sqrt(var_list)
  
  cat("âœ… Seed", s, ": raw_TI_lower NA ìˆ˜ =", sum(is.na(raw_TI_lower)), "\n")
  cat("âœ… Seed", s, ": train_x NA ìˆ˜ =", sum(is.na(train_x)), "\n")
  
  TI_lower_df <- aggregate(raw_TI_lower ~ train_x, FUN = mean)
  TI_upper_df <- aggregate(raw_TI_upper ~ train_x, FUN = mean)
  interp_lower <- approx(x = TI_lower_df$train_x, y = TI_lower_df$raw_TI_lower, xout = test_x)$y
  interp_upper <- approx(x = TI_upper_df$train_x, y = TI_upper_df$raw_TI_upper, xout = test_x)$y
  
  included <- (raw_test_y >= interp_lower) & (raw_test_y <= interp_upper)
  picp <- mean(included, na.rm = TRUE)
  nmpiw <- mean(interp_upper - interp_lower, na.rm = TRUE) / (max(raw_test_y) - min(raw_test_y))
  
  picp_list[s] <- picp
  nmpiw_list[s] <- nmpiw
  
  end_time <- Sys.time()
  cat("âœ… Seed", s, "ì™„ë£Œ - PICP:", round(picp, 4), "NMPIW:", round(nmpiw, 4),
      "| ì†Œìš”ì‹œê°„:", round(as.numeric(end_time - start_time, units = "secs"), 2), "ì´ˆ\n\n")
}

cat("ğŸ“Œ ì „ì²´ í‰ê·  PICP:", round(mean(picp_list), 4), "\n")
cat("ğŸ“Œ ì „ì²´ í‰ê·  NMPIW:", round(mean(nmpiw_list), 4), "\n")
