library(mgcv)
library(fields)
library(MASS)
# í•„ìš”í•œ í•¨ìˆ˜ ì •ì˜
# Hoeffding-style lambda estimation
find_lambda_hat <- function(alpha=0.95, delta=0.90, y, mean_pred, variance, n, lower=0, upper=5){
  f <- function(lambda) {
    risk <- mean(y <= mean_pred - sqrt(variance)*lambda |
                   y >= mean_pred + sqrt(variance)*lambda, na.rm=TRUE)
    threshold <- (1 - alpha) - sqrt(log(1/delta) / (2 * n))
    return(risk - threshold)
  }
  tryCatch({
    uniroot(f, interval = c(lower, upper))$root
  }, error=function(e){
    optimize(f, interval = c(lower, upper))$minimum
  })
}

# ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
data <- read.csv("/Users/hdmt306/Downloads/plasma.csv")

# ë³€ìˆ˜ ëª©ë¡
all_vars <- c("BETADIET", "CALORIES", "CHOLESTEROL", "FAT", 
              "FIBER", "QUETELET", "RETDIET", "AGE")
target_y <- data$BETAPLASMA

# ê²°ê³¼ ì €ì¥
results_summary <- data.frame()

# ë³€ìˆ˜ ì¡°í•© ìƒì„± (ì¤‘ë³µ, ìê¸° ìì‹  ì œì™¸)
var_combinations <- combn(all_vars, 2, simplify = FALSE)

# ë°˜ë³µ
for (vars in var_combinations) {
  x1_name <- vars[1]
  x2_name <- vars[2]
  
  cat(sprintf("\nğŸ”§ í˜„ì¬ ì¡°í•©: x1 = %s, x2 = %s\n", x1_name, x2_name))
  
  picp_list <- c()
  nmpiw_list <- c()
  time_list <- c()
  fallback_count_list <- c()
  
  for (s in 1:50) {
    cat(sprintf("  â–¶ï¸ Seed %d ì‹œì‘...\n", s))
    
    start_time <- Sys.time()
    set.seed(s)
    
    x1 <- data[[x1_name]]
    x2 <- data[[x2_name]]
    y <- target_y
    
    # ê²°ì¸¡ ì œê±°
    complete_idx <- complete.cases(x1, x2, y)
    x1 <- x1[complete_idx]; x2 <- x2[complete_idx]; y <- y[complete_idx]
    
    n <- length(y)
    n_train <- 100
    n_cal <- 100
    n_test <- n- n_train - n_cal #115
    
    all_indices <- sample(seq_len(n))
    train_idx <- all_indices[1:n_train]
    cal_idx <- all_indices[(n_train+1):(n_train+n_cal)]
    test_idx <- all_indices[(n_train+n_cal+1):n]
    
    # ë°ì´í„° (2d) (with scaling)
    # train setë§Œìœ¼ë¡œ í‰ê· ê³¼ í‘œì¤€í¸ì°¨ ì¶”ì •
    train_mean_x1 <- mean(x1[train_idx])
    train_sd_x1   <- sd(x1[train_idx])
    
    train_mean_x2 <- mean(x2[train_idx])
    train_sd_x2   <- sd(x2[train_idx])
    
    train_mean_y <- mean(y[train_idx])
    train_sd_y   <- sd(y[train_idx])
    
    # train/cal/test ê°ê° ë™ì¼ ê¸°ì¤€ìœ¼ë¡œ scaling 
    x1 <- (x1-train_mean_x1) / train_sd_x1
    x2 <- (x2-train_mean_x2) / train_sd_x2
    y <- (y - train_mean_y) / train_sd_y
    
    train_x <- data.frame(x1 = x1[train_idx], x2 = x2[train_idx])
    train_y <- y[train_idx]
    cal_x <- data.frame(x1=x1[cal_idx], x2 = x2[cal_idx])
    cal_y <- y[cal_idx]
    test_x <- data.frame(x1 = x1[test_idx], x2 = x2[test_idx])
    test_y <- y[test_idx]
    
    
    # 1. Train data ì´ìš©í•´ ëª¨ë¸ í•™ìŠµ (í‰ê·  ì˜ˆì¸¡ê°’ ê³„ì‚°)
    fit <- gam(train_y ~ te(train_x$x1,train_x$x2)) #trainìœ¼ë¡œ ë§Œë“  í‰ê· ì¶”ì • ëª¨ë¸
    cal_mean_pred <- predict(fit, train_x = cal_x) #calë¡œ í‰ê· ì˜ˆì¸¡
    
    # 2. Calibration dataë¡œ ì˜ˆì¸¡ ì˜¤ì°¨ì˜ ë¶„ì‚° ì¶”ì • (log scale)
    train_res <- train_y - predict(fit, train_x=train_x)
    log_res2 <- log(train_res^2+1e-8) #log transformation
    
    gam_model <- gam(log_res2~te(train_x$x1, train_x$x2)) #trainìœ¼ë¡œ ë§Œë“  ë¶„ì‚°ì¶”ì • ëª¨ë¸
    log_pred <- predict(gam_model, train_x = cal_x) #calë¡œ ë¶„ì‚° ì˜ˆì¸¡
    cal_variance <- exp(log_pred) 
    
    # 3. Tolerance Interval ê³„ì‚° (ë¶„ì‚° í¬í•¨)
    lambda_hat <- find_lambda_hat(alpha=0.95, delta=0.90, cal_y, cal_mean_pred, cal_variance, length(cal_y))
    
    TI_upper <- cal_mean_pred + sqrt(cal_variance) * lambda_hat
    TI_lower <- cal_mean_pred - sqrt(cal_variance) * lambda_hat
    
    
    # 4. ì™¸ì‚½ ë³´ê°„ì„ ì´ìš© : Thin Plate Spline ëª¨ë¸ì„ ìƒˆë¡­ê²Œ ìƒì„±
    library(fields)
    tps_lower <- Tps(x=as.matrix(cal_x), Y=TI_lower)
    tps_upper <- Tps(x=as.matrix(cal_x), Y=TI_upper) 
    #----------------#Warning : ëª¨ë¸ì´ ê³¼í•˜ê²Œ ì •ê·œí™”ë˜ì–´ ë§¤ë„ëŸ¬ìš´ ë³´ê°„ì„ í•œ ìƒíƒœ. ì¼ë‹¨ ì•ˆì •ì ì¸ ì™¸ì‚½ì„ ìœ„í•´ ê²½ê³  ìŠ¤í‚µ.
    
    
    test_TIlower <- predict(tps_lower, x=as.matrix(test_x))
    test_TIupper <- predict(tps_upper, x = as.matrix(test_x))
    
    cat("ì„ í˜•ë³´ê°„ìœ¼ë¡œ ê°€ëŠ¥í•œ test ê°œìˆ˜:", sum(!is.na(test_TIlower)), "/", length(test_y), "\n") 
    # test point ëª¨ë‘ê°€ expolation .... 
    # ê·¸ë˜ë„ ê²°ê³¼ê°€ ì¢‹ìœ¼ë‹ˆ ê´œì°®ë‚˜? 
    
    #5. ê²°ê³¼ ì¶œë ¥ (Evaluation)
    covered <- (test_y >= test_TIlower) & (test_y <= test_TIupper)
    widths <- TI_upper - TI_lower #ê¸°ì¡´ TI ì‚¬ìš© 
    MPIW <- mean(widths)
    PICP <- mean(covered)
    NMPIW <- MPIW / (max(test_y) - min(test_y))
    
    end_time <- Sys.time()
    time_elapsed <- as.numeric(end_time - start_time, units = "secs")
    
    cat(sprintf("  âœ… Seed %d ì™„ë£Œ - PICP: %.4f, NMPIW: %.4f, fallback k: %d, ì‹œê°„: %.2f ì´ˆ\n",
                s, PICP, NMPIW, sum(fallback_flags), time_elapsed))
    picp_list <- c(picp_list, PICP)
    nmpiw_list <- c(nmpiw_list, NMPIW)
    time_list <- c(time_list, time_elapsed)
    fallback_count_list <- c(fallback_count_list, sum(fallback_flags))
  }
  
  # í‰ê· ê°’ ì €ì¥
  results_summary <- rbind(results_summary, data.frame(
    x1 = x1_name,
    x2 = x2_name,
    mean_PICP = mean(picp_list),
    mean_NMPIW = mean(nmpiw_list),
    mean_time = mean(time_list),
    total_fallbacks = sum(fallback_count_list),
    mean_fallbacks_per_run = mean(fallback_count_list)
  ))
  
  cat(sprintf("ğŸŸ¢ ì¡°í•© ì™„ë£Œ: %s + %s â†’ í‰ê·  PICP: %.4f | í‰ê·  NMPIW: %.4f | í‰ê·  ì‹œê°„: %.2fì´ˆ | ì´ fallback: %dê°œ\n",
              x1_name, x2_name, mean(picp_list), mean(nmpiw_list), mean(time_list), sum(fallback_count_list)))
  
}

results_summary
