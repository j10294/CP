library(splines)
library(foreach)
library(doParallel)

# 1. ë°ì´í„° ìƒì„± í•¨ìˆ˜ ì •ì˜
generate_data <- function(model, n) {
  x <- seq(0, 10, length.out = n)
  pop <- 3 * cos(x) - 5 * (x / 15)^2
  if (model == 1) {
    y <- 3 * cos(x) - 5 * (x / 15)^2 + rnorm(n, mean = 0, sd = sqrt(2))
  }
  if (model == 2) {
    y <- 3 * cos(x) - 5 * (x / 15)^2 + rnorm(n, mean = 0, sd = sqrt(2 * x))
  }
  if (model == 3) {
    y <- 3 * cos(x) - 5 * (x / 15)^2 + 4 - rgamma(n, shape = 2, scale = 2)
  }
  if (model == 4) {
    y <- 3 * cos(x) - 5 * (x / 15)^2 + rt(n, df = 3)
  }
  return(data.frame(x = x, y = y, pop = pop))
}

# ë²¡í„°ì˜ L2 norm ê³„ì‚° í•¨ìˆ˜
compute_norm <- function(vector) {
  return(sqrt(sum(vector^2)))
}

compute_probability <- function(nu, t, P, k, norm_lx_h) {
  tryCatch({
    q_val <- qchisq(P, df = 1, ncp = t^2)
    lhs <- q_val / ((t * sqrt(5 / nu)) + 1)
    
    # ë²¡í„° ì…ë ¥ ëŒ€ì‘
    out <- numeric(length(q_val))
    
    for (i in seq_along(q_val)) {
      q <- q_val[i]
      l <- lhs[i]
      
      # ê³„ì‚° ë¶ˆê°€í•œ ê²½ìš°
      if (is.nan(q) || is.nan(l) || is.na(q) || is.na(l)) {
        out[i] <- 0
        next
      }
      
      if (l <= k^2) {
        threshold <- (nu * q) / (k^2)
        if (is.nan(threshold) || is.na(threshold)) {
          out[i] <- 0
          next
        }
        
        prob <- pchisq(threshold, df = nu, lower.tail = FALSE)
        if (is.nan(prob) || is.na(prob)) {
          out[i] <- 1e-6
        } else {
          out[i] <- prob
        }
      } else {
        out[i] <- 0
      }
    }
    
    return(out)
  }, error = function(e) {
    warning("compute_probability ê³„ì‚° ì˜¤ë¥˜ ë°œìƒ")
    return(rep(0, length(t)))  # tê°€ ë²¡í„°ë©´ ê·¸ ê¸¸ì´ì— ë§ê²Œ 0 ë°˜í™˜
  })
}


# ì ë¶„ í•¨ìˆ˜
integrand <- function(t, k, nu, P, norm_lx_h) {
  exp_term <- exp(-t^2 / (2 * norm_lx_h^2))
  prob_term <- compute_probability(nu, t, P, k, norm_lx_h)
  
  if (log(exp_term) < -20) {
    #cat(sprintf("âš ï¸ ë„ˆë¬´ ì‘ì€ ì ë¶„í•­: log(exp) = %.2f (t = %.4f, k = %.4f)\n",
                log(exp_term), t, k))
    return(1e-10)
  }
  
  return(exp_term * prob_term)
}

# upper bound ê³„ì‚° í•¨ìˆ˜
find_upper_bound_t <- function(k, nu, P) {
  t_seq <- seq(0.01, 20, by = 0.1)
  valid_t <- sapply(t_seq, function(t) {
    q_val <- qchisq(P, df = 1, ncp = t^2)
    lhs <- q_val / ((t * sqrt(5 / nu)) + 1)
    return(length(lhs) == 1 && !is.na(lhs) && lhs <= k^2)
  })
  
  if (any(valid_t)) {
    return(max(t_seq[valid_t]))
  } else {
    warning("ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” tê°€ ì—†ìŒ â€” fallback to t = 15")
    return(15)
  }
}

# k-factor ê³„ì‚° í•¨ìˆ˜
find_k_factor <- function(nu, norm_lx_h, P = 0.90, gamma = 0.95, index = NA) {
  start_time <- Sys.time()
  cat("â–¶ï¸ k-factor ê³„ì‚° ì‹œì‘: index =", index, "\n")
  
  obj_func <- function(k) {
    upper_bound <- find_upper_bound_t(k, nu, P)
    
    if (is.na(upper_bound) || is.infinite(upper_bound) || upper_bound < 1e-6) {
      warning("upper_boundê°€ ì´ìƒí•¨ â†’ fallback")
      return(1e6)
    }
    
    tryCatch({
      integral_result <- integrate(
        Vectorize(integrand),   # í•¨ìˆ˜ ë²¡í„°í™”
        lower = 0, upper = upper_bound,
        k = k, nu = nu, P = P, norm_lx_h = norm_lx_h
      )$value
      
      pi_term <- sqrt(2 / (pi * norm_lx_h^2))
      final_val <- pi_term * integral_result
      error <- abs(final_val - gamma)
      
      cat(sprintf("ğŸ§ª [OK] k=%.4f | norm=%.4f | integral=%.3e | final=%.5f | gamma=%.2f | error=%.4f\n",
                  k, norm_lx_h, integral_result, final_val, gamma, error))
      return(error)
    }, error = function(e) {
      cat(sprintf("âŒ ì ë¶„ì—ì„œ ì—ëŸ¬: k=%.4f, norm=%.4f\n", k, norm_lx_h))
      cat("ğŸ” ì´ìœ : ", e$message, "\n")
      return(Inf)
    })
  }
  
  tryCatch({
    out <- optimize(obj_func, interval = c(0.01, 10), tol = 1e-2)$minimum
    elapsed <- Sys.time() - start_time
    cat("âœ… index =", index, ", ìµœì  k =", round(out, 5), ", ì‹œê°„:", round(elapsed, 2), "ì´ˆ\n")
    return(out)
  }, error = function(e) {
    warning("k ìµœì í™” ì‹¤íŒ¨ â†’ fallback ì ìš©ë¨ (index =", index, ")")
    return(NA)
  })
}


# 6. ë°ì´í„° ë³€í™˜ í•¨ìˆ˜ 
transform_function <- function(models, sample_sizes, M, seed) {
  set.seed(seed)
  transformed_data_list <- list()
  raw_data_list <- list()
  
  for (model in models) {
    for (m in sample_sizes) {
      transformed_data <- matrix(NA, nrow = m, ncol = M)
      raw_data <- vector("list", M)
      
      # ë°ì´í„°ì˜ ë¶„ì‚°ì„ ì¶”ì •í•´ ì¶”ì •ëœ ë¶„ì‚°ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë‚˜ëˆ„ì–´ transform
      for (i in 1:M) {
        data <- generate_data(model, m)
        x <- data$x
        y <- data$y
        fit <- smooth.spline(x = x, y = y, cv = FALSE) #ë…¼ë¬¸ ë°©ë²•ê³¼ ë™ì¼í•˜ê²Œ GCV ì‚¬ìš©
        pred_y <- predict(fit, x)$y
        residuals <- y - pred_y
        
        log_variance_fit <- smooth.spline(x = x, y = log(residuals^2 + 1e-6), cv = FALSE)
        log_variance_hat <- predict(log_variance_fit, x)$y
        variance_hat <- exp(log_variance_hat)
        
        variance_hat[is.nan(variance_hat) | is.infinite(variance_hat)] <- 1e-6
        transform_y <- y / sqrt(variance_hat)
        
        transformed_data[, i] <- transform_y
        raw_data[[i]] <- data.frame(x = x, y = y, variance_hat = variance_hat)
      }
      
      transformed_data_list[[paste0("Model_", model, "_m_", m)]] <- transformed_data
      raw_data_list[[paste0("Model_", model, "_m_", m)]] <- raw_data
    }
  }
  
  return(list(transformed = transformed_data_list, raw = raw_data_list))
}

# 7. ì‹œê°í™” í•¨ìˆ˜
plot_ti <- function(x, y, TI_lower, TI_upper, pred_mean, varname, covered, picp, nmpiw, cwc) {
  df <- data.frame(
    x = x, y = y,
    lower = TI_lower, upper = TI_upper,
    pred = pred_mean, covered = covered
  )
  p <- ggplot(df, aes(x = x, y = y)) +
    geom_point(aes(color = covered), size = 1.5) +
    geom_ribbon(aes(ymin = lower, ymax = upper), fill = "green", alpha = 0.3) +
    geom_line(aes(y = pred), color = "darkgreen", size = 0.7) +
    labs(
      title = paste0("TI for ", varname),
      subtitle = sprintf("PICP=%.3f, NMPIW=%.3f, CWC=%.3f", picp, nmpiw, cwc),
      x = "x", y = varname
    ) +
    theme_minimal(base_size = 11) +
    scale_color_manual(values = c("TRUE" = "blue", "FALSE" = "red"))
  return(p)
}
